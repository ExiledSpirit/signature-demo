# Portuguese

# Sobre

Esse projeto é uma demonstração básica de como implementar assinatura de documentos em um projeto java. Essa demonstração será utilizada em uma implementação em um projeto real, por isso alguns examplos como a explicação da entidade documento são um pouco mais específicos.

## Entidade Relacionamento
![Diagrama de Entidade-Relacionamento](https://i.imgur.com/SRbQGzc.png)

Apesar de serem baseados em um exemplo real, essas entidades foram simplificadas a fim de deixar a explicação mais simples.

### Author

Representa o usuário da aplicação. As chaves públicas e privadas podem ser chamadas de keypairs. Apesar de terem sido geradas utilizando um algorítmo RSA, eu recomendo utilizar EEC (Elliptic Curve Cryptography) em uma implementação real, pois é o recomendado para essa abordagem [Veja mais](https://www.ssl2buy.com/wiki/rsa-vs-ecc-which-is-better-algorithm-for-security).

### documento

Representa o dado que será assinado. Ele contém informações como o autor que escreveu, o conteúdo em texto e uma propriedade "hash". Essa propriedade hash guarda o resultado do calculo usando um algorítmo de criptografia (como o SHA-256) sobre o conteúdo. Isso garante que o documento não foi modificado, e é essa coluna que vai ser utilizada para gerar a assinatura.

Por exemplo, se o documento tiver uma tabela filha para armazenar arquivos, então ela deveria ter uma coluna "hash" para garantir a integridade desses arquivos. Esses hashes seriam então utilizados para gerar o hash do documento.

### assinatura

Representa a assinatura feita por um usuário sobre um documento.

A assinatura é gerada criptografando a hash de um documento utilizando a chave privada do autor. Para validar essa assinatura, é importante seguir os seguintes passos:?

1. **Verificar a Integridade do Documento:** Recalcule o hash do documento usando as mesmas etapas de quando ele foi gerado e compare-o com o hash armazenado. Neste exemplo, usamos apenas o conteúdo para gerar o hash, mas para cenários da vida real, é recomendável incluir mais dados (por exemplo, ID do autor, hashes de arquivo).

2. **Descriptografar a Assinatura:** Descriptografe a assinatura usando a chave pública do usuário. Ele deve retornar uma string que corresponde ao hash do documento se tudo estiver válido.

Este processo deve ser suficiente para a validação da assinatura. Embora o código possa regenerar a assinatura para comparação, geralmente é considerado desnecessário e pode não ser a melhor prática.

## Considerações

O núcleo dessa arquitetura de hash e assinatura é o hash do documento. É crucial escolher um algoritmo de hash seguro (como SHA-256) para calcular o hash. Esse hash é usado para gerar a assinatura, portanto, certifique-se de que ele incorpora todos os dados relevantes, incluindo conteúdo, bytes de arquivo (armazenados na coluna hash para eficiência), ID do autor e outras IDs de relacionamento.

# English

# About

This project is a basic demo on how to implement hashing and signatures in a Java project. This demo will be used to guide a major implementation in a real-life application, so some examples, such as the document explanation, are more specific.

## Entity Relationship

![Entity-Relationship Diagram](https://i.imgur.com/yYMurmD.png)

Even though they are based on real-life cases, the entities were simplified for easier explanation.

### Author

Represents the application user. The private and public keys are also called keypairs. Although they were generated using the RSA algorithm in this example, using Elliptic Curve Cryptography (ECC) is recommended for real-life projects due to its security benefits. [More here](https://www.ssl2buy.com/wiki/rsa-vs-ecc-which-is-better-algorithm-for-security)

### Document

Represents the data to be signed. It contains information about the author, text content, and a "hash" property. The hash property stores the result of a calculation using a secure hashing algorithm (like SHA-256) on the content. This ensures the document hasn't been tampered with. Additionally, this hash is used to generate the signature.

For example, if the document has a child table for files, they would also need a "hash" column to ensure the integrity of the files. These hashes would also be used to generate the document hash.

### Signature

Represents the signature made by a user on a document.

This signature is generated by encrypting the hash of a Document using the Author's private key. To validate the signature:

1. **Verify Document Integrity:** Recalculate the document hash using the same steps as when it was generated, and compare it with the stored hash. In this example, we only use the content to generate the hash, but for real-life scenarios, it's recommended to include more data (e.g., author ID, file hashes).
2. **Decrypt the Signature:** Decrypt the signature using the user's public key. It should return a string that matches the document hash if everything is valid.

This process should be sufficient for signature validation. While the code might regenerate the signature for comparison, it's generally considered unnecessary and might not be the best practice.

## Considerations

The core of this hashing and signing architecture is the document hash. Choosing a secure hashing algorithm (like SHA-256) to calculate the hash is crucial. This hash is used to generate the signature, so ensure it incorporates all relevant data, including content, file bytes (stored in the hash column for efficiency), author ID, and other relationship IDs.
